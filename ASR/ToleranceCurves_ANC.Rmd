---
title: "Goolsby Methods -- Emery Data"
author: "Silas Tittes"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    fig_caption: yes 
---


```{r, message=FALSE}
#load all data
source("bayes/load_data.R")
source("ASR/functions.R")
```

Ancestral state reconstruction of tolerance curves. 

IGNORE FIRST TWO BLOCKS

First, lets simulate some data from the stretched kumarswamy function.
```{r, fig.cap="Simulated tolerance curves. The e and d parametes are included, which allows for shifts in the index variable range.", message=FALSE}

#sketchy upper half normal 
rhnorm <- function(n, mu, sigma, half){
  init1 <- rnorm(n*10, mu, sigma)
  init2 <- init1[init1 >= half]
  init3 <- sample(x = init2, size = n, replace = T)
  return(init3)
}

#sketchy lower half normal
rlhnorm <- function(n, mu, sigma, half){
  init1 <- rnorm(n*10, mu, sigma)
  init2 <- init1[init1 <= half]
  init3 <- sample(x = init2, size = n, replace = T)
  return(init3)
}


#data structure and size
nSpp <- length(lasth$tip.label)
ncurve <- 20 #number of points to make curve with
xseq <- seq(0,1, length.out=ncurve)


#parameters for each species
a <- rhnorm(n = nSpp, mu = 5, sigma =  1, half = 2)
b <- rhnorm(n = nSpp, mu = 5, sigma =  1, half = 2)
c <- rhnorm(n = nSpp, mu = 1, sigma =  2, half = 2)
d <- rlhnorm(n = nSpp, mu = 1 , sigma =  5, half = 1)
e <- rhnorm(n = nSpp, mu = 5, sigma = 5, half = 5)
e1 <- e - d
sigma <- rhnorm(n = 1, mu = 0, sigma =  2, half = 0)

#array organization
#first row of each page is x values
#second row of each page is y values
#each page is a species
curveDat <- array(NA, dim=list(2, ncurve, nSpp))
for(i in 1:nSpp){
  curveDat[1,,i] <- xseq*e[i] -d[i] #observation scaled x vales
  curveDat[2,,i] <- stretch.kumara(x = xseq, a[i], b[i], c[i]) #tolerance values
}


#looks good
plot(curveDat[1,,i],curveDat[2,,i], type="n", xlim=range(curveDat[1,,]), ylim=range(curveDat[2,,]), xlab="Index variable", ylab="performance")
for(i in 1:nSpp){
  vals <- runif(3)
  coli <- rgb(red = vals[1], green = vals[2], blue = vals[3])
  lines(curveDat[1,,i],curveDat[2,,i], col=coli, lwd=3)
}

```


```{r, message=FALSE, fig.cap="The Lasthenia tree (left), and randomly assigned curves (right). The red line shows the estimated ancestral curve. I need to read more, but as far as I can tell, this must be a reconstruction for the most recent common ancestor. Each curve must be reconstructed over a x variable range."}
lasthSub <- subtrees(lasth)

#for (z in 1:length(lasthSub)){
for (z in 1){
  
  cSubTree <- lasthSub[[z]]
  cTaxa <- lasth$tip.label %in% cSubTree$tip.label 
  
  cCurveData <- curveDat[2,,cTaxa]
  Y <- t(cCurveData)
  rownames(Y) <- cSubTree$tip.label
  anc_Y <- fast_anc_hand(xseq, Y, cSubTree, T, T)
  
  par(mfrow=c(1,2))
  
  
  plot(cSubTree)
  plot(xseq,cCurveData[,z], type="n", ylim=range(cCurveData[,]), xlab="Index variable", ylab="performance")
  for(i in 1:ncol(cCurveData)){
    lines(xseq,cCurveData[,i], lwd=2)
  }
  lines(xseq, anc_Y, lwd=4, col="red")
  
  par(mfrow=c(1,1))
}


physignal(Y, cSubTree)
dim(cCurveData)
plot(lasth)
```


Curve Signal
```{r}
nspp <- nrow(unique(emery[,c(2,7)]))
xseq_comm <- seq(1,5, length.out=200)

sppMaxVal <- by(data = emery$Inflor_biomass, INDICES = emery$sppint, FUN = max)
names(sppMaxVal) <- unique(emery$Species)



draw_list <- as.list(1:ndraws) #posterior draws as list
sppint_list <- as.list(1:max(emery$sppint)) #species are columns
curveK_draws <- sapply(draw_list, 
                       function(pr){ spp_mat <- t(sapply(sppint_list, function(sp){
                          scale.kumara(xs = xseq_comm,
                                 a = posts$a[pr,sp],
                                 b = posts$b[pr,sp],
                                 c = posts$c[pr,sp],
                                 d = posts$d[pr,sp],
                                 e1 = posts$e1[pr,sp]
                                 )
                    })
                  )
                    rownames(spp_mat) <- unique(emery[,2])
                    physignal(A = spp_mat, phy = lasth, iter = 1)$phy.signal
                  })



curveK_draws_scaled <- sapply(draw_list, function(pr){
                  spp_mat <- t(sapply(sppint_list, function(sp){
                    scale.kumara(xs = xseq_comm,
                                 a = posts$a[pr,sp],
                                 b = posts$b[pr,sp],
                                 c = posts$c[pr,sp]/sppMaxVal[sp], #alt
                                 d = posts$d[pr,sp],
                                 e1 = posts$e1[pr,sp]
                                 )
                    })
                  )
                    rownames(spp_mat) <- unique(emery[,2])
                    physignal(A = spp_mat, phy = lasth, iter = 1)$phy.signal
                  })

den_curves <- lapply(list(curveK_draws, curveK_draws_scaled), density)
xrng <- range(sapply(den_curves, function(x) x$x))
yrng <- range(lapply(den_curves, function(x) x$y))
plot(NA, NA, ylim=yrng, xlim = xrng,
     xlab = "K", ylab = "density")
polygon(density(curveK_draws), col = alpha("green", 0.5))
polygon(density(curveK_draws_scaled), col = alpha("blue", 0.5))
legend("topright", c("unscaled","scaled"), pch = 21, pt.bg = c(alpha("green", 0.5),alpha("blue", 0.5)))
```


OUwie
```{r}

#avoid the annoying hit enter for next plot thing
par(ask=F)

#Set up data for OUwie
Genus_species <- as.character(unique(emery$Species))
Reg <- c("terrestrial", "vernal", "vernal",
         "vernal", "vernal", "vernal",
         "aqua_terr", "vernal", "vernal",
         "aqua_terr", "terrestrial", "aqua_terr",
         "vernal", "terrestrial"
         )


state_reg <- Reg
names(state_reg) <- as.character(Genus_species)


#ml est for habitat reconstruction
regFit_ml <- rerootingMethod(lasth, state_reg, model = "ER", tips = T)
#stochastic mapping for anc. state. recon. of habitat

#number of stochastic maps of habitat
mapsims <- 100

describe.simmap(reg_fit)
reg_fit$mapped.edge
reg_fit$maps


#generate maps
reg_fit <- make.simmap(tree = lasth, state_reg, model = "ER", nsim = mapsims)

#analyze transitions
tt <- 8
colnames(countSimmap(reg_fit)$Tr)[tt]
plot(table(countSimmap(reg_fit)$Tr[,tt]))
quantile(countSimmap(reg_fit)$Tr[,tt], c(0.225, 0.975))

#prep for OUwie
states <- colnames(reg_fit[[1]]$mapped.edge)
names(states) <- c("red", "green", "blue")
colz <- names(states)
names(colz) <- states

#example map
plotSimmap(reg_fit[[1]], colors = colz)

#assign node habitat state randomly and propto post probs
simstates <- lapply(reg_fit, function(x){
  states[apply(x$mapped.edge, 1, which.max)]
  #apply(x$mapped.edge, 1, function(z){
  #sample(x = states, size = 1, prob = z, replace = F)})
  })

#assign habitat to ml nodes
states_ml <- apply(regFit_ml$marginal.anc, 1, function(x) states[which.max(x)])

#subset to nodes only
anc_sims <- lapply(simstates, function(x) x[lasth$edge[,2] > length(lasth$tip.label)])
hab_sims <- lapply(simstates, function(x) x)

#function to apply OUwie over posterior tolerance draws, and stochastic map draws
#OUwie data frame = taxa, regime, trait value
ouwie_draws <- function(draws, df, mod, tree, sims){
  
  #process across stochastic map sims
  mapdraw <- lapply(sims, function(y){
    #combine true tips states to stochastic map anc states
    anc_states <- y[tree$edge[,2] >= length(tree$tip.label)]
    tree$node.label <- anc_states
    tip_states <- y[tree$edge[,2] <= length(tree$tip.label)]
    
    #run posterior draws against each stochastic habitat reconstruction
    draws <- lapply(X = as.list(1:draws), FUN = function(x){
      X <- matrix(df[x,])
      #X <- apply(maximadf, 2, mean)
      ouwieDat <- data.frame(Genus_species=Genus_species,
                             Reg=tip_states, X=unlist(X))
      ouwieOUMVA <- OUwie(tree, data = ouwieDat,
                          model = mod, root.station = T)
    #message(x)
    })
  })
  return(mapdraw)
}


ouwie_draws_ml <- function(draws, df, mod, tree, anc){
    
    anc_states <- anc[tree$edge[,2] > length(tree$tip.label)]
    tree$node.label <- anc_states
    tip_states <- anc[tree$edge[,2] <= length(tree$tip.label)]
    
    #run posterior draws against each stochastic habitat reconstruction
    draws <- lapply(X = as.list(1:draws), FUN = function(x){
      X <- matrix(df[x,])
      #X <- apply(maximadf, 2, mean)
      ouwieDat <- data.frame(Genus_species=Genus_species,
                             Reg=tip_states, X=unlist(X))
      ouwieOUMVA <- OUwie(tree, data = ouwieDat,
                          model = mod, root.station = T)
    })
  return(draws)
}

get_thetas <- function(ouwie_out){
  lapply(ouwie_out, function(y) sapply(y, function(x)x$theta[,1]))  
}

get_aicc <- function(ouwie_out){
  lapply(ouwie_out, function(y) sapply(y, function(x)x[["AICc"]]))
}

get_aic <- function(ouwie_out){
  lapply(ouwie_out, function(y) sapply(y, function(x)x[["AIC"]]))
}

plot_ouwie_draws <- function(ouwie_draw_list){
  
  credz <- sapply(as.list(1:3), function(y){
    quantile(sapply(ouwie_draw_list,
                    function(x) x[["theta"]][[y]]),c(0.025, 0.975))
  }
  )
  
  denz <- lapply(as.list(1:3), function(y){
    density(sapply(ouwie_draw_list, function(x) x[["theta"]][[y,1]]))
    })
  
  xrng <- range(sapply(denz, function(z) z$x))
  yrng <- range(sapply(denz, function(z) z$y))
  
  plot(NA, NA, xlim=xrng, ylim=yrng, xlab="", ylab="")
  
  lapply(denz, function(z) lines(z$x, z$y))
  
  segments(x0 = credz[1,], y0 = yrng[2]*c(0.2, 0.22, 0.23), 
           x1 = credz[2,], y1 = yrng[2]*c(0.2, 0.22, 0.23), col=colz)
}

compare_ouwie_draws <- function(ouwie_draw_list){
  
  aq_terr_terr <- mean(sapply(ouwie_draw_list,
                              function(x)x[["theta"]][[1,1]]) 
                       >
                         sapply(ouwie_draw_list,
                                function(x)x[["theta"]][[2,1]]))
  
  aq_terr_vern <- mean(sapply(ouwie_draw_list,
                              function(x)x[["theta"]][[1,1]]) 
                       >
                         sapply(ouwie_draw_list,
                                function(x)x[["theta"]][[3,1]]))
  
  terr_vern <- mean(sapply(ouwie_draw_list, 
                           function(x)x[["theta"]][[2,1]]) 
                    >
                      sapply(ouwie_draw_list,
                             function(x)x[["theta"]][[3,1]]))
  
  return(list(aq_terr_terr = aq_terr_terr, 
              aq_terr_vern = aq_terr_vern, 
              terr_vern = terr_vern))
}


### WITH maximum likelihood

ouwie_c_ml_ou1 <- ouwie_draws_ml(df = posts$c, draws = 100, 
                                 mod = "OU1", tree = lasth,
                                 states_ml)

ouwie_c_ml_oum <- ouwie_draws_ml(df = posts$c, draws = 100, 
                                 mod = "OUM", tree = lasth,
                                 states_ml)


quantile(sapply(ouwie_c_ml_ou1, function(x) x$AICc))
quantile(sapply(ouwie_c_ml_oum, function(x) x$AICc))

### WITH stochastic mapping

ouwie_c_ou1 <- ouwie_draws(df = posts$c, draws = 100, 
                                mod = "OU1", tree = lasth, 
                                sims =  hab_sims)

ouwie_c_oum <- ouwie_draws(df = posts$c, draws = 100, 
                                mod = "OUM", tree = lasth, 
                                sims = hab_sims)

hist(unlist(lapply(get_aicc(ouwie_out = ouwie_c_ou1), function(x) x)), 
     breaks = 20)
hist(unlist(lapply(get_aicc(ouwie_out = ouwie_c_oum), function(x) x)),
     breaks = 20)

mean(unlist(lapply(get_aicc(ouwie_out = ouwie_c_ou1), function(x) x)) < unlist(lapply(get_aicc(ouwie_out = ouwie_c_oum), function(x) x)))


#dev.off()
#get all aquatic-terr into a single vector 
unlist(lapply(get_thetas(ouwie_c_oum), function(x)x[1,]))
#get all terrestrial into a single vector 
unlist(lapply(get_thetas(ouwie_c_oum), function(x)x[2,]))
#get all vernal into a single vector
unlist(lapply(get_thetas(ouwie_c_oum), function(x)x[3,]))





#ouwieBM <- OUwie(lasth, data = ouwieDat, model = "BM1",root.station = T)
#ouwieOU1 <- OUwie(lasth, data = ouwieDat, model = "OU1",root.station = T)
#ouwieOUM <- OUwie(lasth, data = ouwieDat, model = "OUM",root.station = T)
#ouwieOUMV <- OUwie(lasth, data = ouwieDat, model = "OUMV",root.station = T)
#ouwieOUMA <- OUwie(lasth, data = ouwieDat, model = "OUMA", root.station = T)
```







Plot density of posteriors
```{r}

maxima_means <- apply(X = maximadf, MARGIN = 2, FUN = mean)
maxima_means2 <- sort(maxima_means[names(maxima_means) %in%
                                     lasth$tip.label],decreasing = T)

mden <- apply(maximadf, 2, density)
mden <- apply(posts$a, 2, density)

ylimit <- max(sapply(mden, function(x) max(x$y)))
xlimit <- range(sapply(mden, function(x) range(x$x)))
par(mar=c(5,0,4,0))
plot(NA,NA, 
     xlim=xlimit, 
     ylim=c(0,ylimit),
     xlab="", ylab="", main="",
     axes=F)

sapply(mden, FUN = function(x) lines(x = x$x, y = x$y) )
legend("topright", 
       names(sort(maxima_draw_2, decreasing = T)), 
       bty="n", cex = 1, text.font = 3)

#dev.off()

maxima_k <- phylosignal(x = maxima_means_2, phy = lasth)
maxima_k
```

Function for plotting phenogram
```{r}

phenoCred <- function( trait_chain, tree, fig_name){
  
  #trait_chain <- posts$c
  #tree <- lasth
  
  
  colnames(trait_chain) <- unique(emery$Species)
  
  
  trait_means <- apply(X = trait_chain, MARGIN = 2, FUN = mean)
  
  xmx <- 1.6
  lmeans <- length(trait_means)
  zz <- seq(1.1,xmx, length.out = lmeans)
  
  credz <- apply(X = trait_chain, 
                 MARGIN = 2, 
                 FUN = quantile, c(0.025, 0.975))
  
  credz2 <- credz[ ,colnames(credz) %in% tree$tip.label  ]
    
  mean_trait2 <- sort(trait_means[names(trait_means) %in% tree$tip.label],
                       decreasing = T)
  
  credz_ordered <- credz2[,names(mean_trait2)]
  
  pdf(file = fig_name)
  
  ylimz <- range(credz_ordered)
  plot(NA, NA, xlim=c(0,xmx), ylim=c(ylimz[1], ylimz[2]*1.1), 
       axes=F, ylab=fig_name, xlab="")
  mtext(text = "Time", side = 1, line = 3, at = 0.85/2)
  test <- phenogram(tree = tree,
            x = mean_trait2,
            colors = "dodgerblue",
            xlim=c(0,1.55), ylim=range(credz), ftype = "i",
            add=T)
  
  colz <- as.color( x = 1:length(mean_trait2), alpha = 1)
  
  xset <- round(seq(0, 0.85, length.out=4), 2)
  axis(side = 1, at = xset)
  axis(2)
  
  for(i in 1:lmeans){
    cNode <- which(tree$tip.label == names(mean_trait2)[i])
    nodelabels(
    text = substr(names(mean_trait2), start = 1, stop = 3)[i],
    node = cNode,
    adj = -0.2,
    frame = "none",
    col = colz[i])  
    }
  
  #plot(NA, NA, xlim=c(0.75,1), ylim=c(2.2, 3.7))
  sz <- 1000
  for(i in sample(x = 1:ndraws, size = sz, replace = F)){
    trait_draw <- apply(X = trait_chain, 
                        MARGIN = 2, 
                        function(x) x[[i]]
                        )
    
    trait_draw_2 <- trait_draw[names(trait_draw) %in%
                                   tree$tip.label]
    
    phenogram(tree = tree, trait_draw_2, add = T,
              col=alpha(colour = "black", alpha = 0.01))
  
    phenogram(tree = tree, 
              x = mean_trait2, 
              colors = "dodgerblue",  
              add = T)
  }
  
  legend("topleft", 
         names(mean_trait2), 
         bty="n", cex = 1, text.font = 3, text.col = colz)
  
  arrows(x0 = zz,
         y0 = credz_ordered[1,],
         x1 = zz,
         y1 = credz_ordered[2,],
         length = 0.05, angle = 90, 
         code = 3, col=colz, lwd=3)
  
  dev.off()
}

phenoCred(trait_chain = posts$a, tree = lasth, fig_name = "figures/parameterA")
phenoCred(trait_chain = posts$b, tree = lasth, fig_name = "figures/parameterB")
phenoCred(trait_chain = posts$c, tree = lasth, fig_name = "figures/parameterC")
phenoCred(trait_chain = posts$d, tree = lasth, fig_name = "figures/parameterD")
phenoCred(trait_chain = posts$e1, tree = lasth, fig_name = "figures/parameterE1")
phenoCred(trait_chain = maximadf, tree = lasth, fig_name = "figures/maxima")
```



